window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "cli_wrapper", "modulename": "cli_wrapper", "kind": "module", "doc": "<p>CLIWrapper represents calls to CLI tools as an object with native python function calls.</p>\n\n<h1 id=\"examples\">Examples</h1>\n\n<pre><code>from json import loads  # or any other parser\nfrom cli_wrapper import CLIWrapper\nkubectl = CLIWrapper('kubectl')\nkubectl._update_command(\"get\", default_flags={\"output\": \"json\"}, parse=loads)\n# this will run `kubectl get pods --namespace kube-system --output json`\nresult = kubectl.get(\"pods\", namespace=\"kube-system\")\nprint(result)\n\nkubectl = CLIWrapper('kubectl', async_=True)\nkubectl._update_command(\"get\", default_flags={\"output\": \"json\"}, parse=loads)\nresult = await kubectl.get(\"pods\", namespace=\"kube-system\")  # same thing but async\nprint(result)\n</code></pre>\n\n<p>You can also override argument names and provide input validators:</p>\n\n<pre><code>from json import loads\nfrom cli_wrapper import CLIWrapper\nkubectl = CLIWrapper('kubectl')\nkubectl._update_command(\"get_all\", cli_command=\"get\", default_flags={\"output\": \"json\", \"A\": None}, parse=loads)\nresult = kubectl.get_all(\"pods\")  # this will run `kubectl get pods -A --output json`\nprint(result)\n\ndef validate_pod_name(name):\n    return all(\n        len(name) &lt; 253,\n        name[0].isalnum() and name[-1].isalnum(),\n        all(c.isalnum() or c in ['-', '.'] for c in name[1:-1])\n    )\nkubectl._update_command(\"get\", validators={1: validate_pod_name})\nresult = kubectl.get(\"pod\", \"my-pod!!\")  # raises ValueError\n</code></pre>\n\n<h1 id=\"callable-serialization\">Callable serialization</h1>\n\n<p>Argument validation and parser configuration are not straightforward to serialize. To get around this, CLI Wrapper uses\n<code>CallableRegistry</code> and <code>CallableChain</code>. These make it somewhat more straightforward to create more serializable wrapper\nconfigurations.</p>\n\n<h2 id=\"tldr\">TL;DR</h2>\n\n<ul>\n<li>Functions that perform validation, argument transformation, or output parsing are registered with a name in a\n<code>CallableRegistry</code></li>\n<li><p><code>CallableChain</code> resolves a serializable structure to a sequence of calls to those functions</p>\n\n<ul>\n<li>a string refers to a function, which will be called directly</li>\n<li>a dict is expected to have one key (the function name), with a value that provides additional configuration:\n<ul>\n<li>a string as a single positional arg</li>\n<li>a list of positional args</li>\n<li>a dict of kwargs (the key \"args\" will be popped and used as positional args if present)</li>\n</ul></li>\n<li>a list of the previous two</li>\n</ul></li>\n<li><p>A list of validators is treated as a set of conditions which must be true</p></li>\n<li>A list of parsers will be piped together in sequence</li>\n<li>Transformers receive an arg name and value, and return another arg and value. They are not chained.</li>\n</ul>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>Here's how these work:</p>\n\n<h3 id=\"callableregistry\"><code>CallableRegistry</code></h3>\n\n<p>Callable registries form the basis of serializing callables by mapping strings to functions. If you are doing custom\nparsers and validators and you want these to be serializable, you will use their respective callable registries to\nassociate the code with the serializable name.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">greater_than</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n  <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"n\">b</span>\n\n\n<span class=\"n\">registry</span> <span class=\"o\">=</span> <span class=\"n\">CallableRegistry</span><span class=\"p\">(</span>\n  <span class=\"p\">{</span>\n    <span class=\"s2\">&quot;core&quot;</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n<span class=\"n\">registry</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">&quot;gt&quot;</span><span class=\"p\">,</span> <span class=\"n\">greater_than</span><span class=\"p\">)</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">registry</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">&quot;gt&quot;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"n\">x</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<h3 id=\"callablechain\"><code>CallableChain</code></h3>\n\n<p>A callable chain is a serializable structure that gets converted to a sequence of calls to things in a\n<code>cli_wrapper.util.callable_registry.CallableRegistry</code>. It is an abstract base class, and so shouldn't be created directly; subclasses are expected to\nimplement <code>__call__</code>. We'll use the <code>.validators.Validator</code> class as an example. <code>validators</code> is a <code>CallableRegistry</code> with all of\nthe base validators (<code>is_dict</code>, <code>is_list</code>, <code>is_str</code>, <code>startswith</code>...)</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Say we have these validators that we want to run:</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">every_letter_is</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">all</span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">lower</span><span class=\"p\">())</span> <span class=\"ow\">or</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">upper</span><span class=\"p\">())</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\n<span class=\"n\">validators</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">&quot;every_letter_is&quot;</span><span class=\"p\">,</span> <span class=\"n\">every_letter_is</span><span class=\"p\">)</span>\n\n<span class=\"n\">my_validation</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&quot;is_str&quot;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">&quot;every_letter_is&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;a&quot;</span><span class=\"p\">}]</span>\n\n<span class=\"n\">straight_as</span> <span class=\"o\">=</span> <span class=\"n\">Validator</span><span class=\"p\">(</span><span class=\"n\">my_validation</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">straight_as</span><span class=\"p\">(</span><span class=\"s2\">&quot;aaaaAAaa&quot;</span><span class=\"p\">))</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"n\">straight_as</span><span class=\"p\">(</span><span class=\"s2\">&quot;aaaababa&quot;</span><span class=\"p\">))</span>\n</code></pre>\n</div>\n\n<p><code>Validator.__call__</code> just checks that every validation returns true. Elsewhere, <code>Parser</code> pipes inputs in sequence:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"nt\">parser</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">yaml</span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"nt\">extract</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">result</span><span class=\"w\"> </span>\n</code></pre>\n</div>\n\n<p>This would first parse the output as yaml and then extract the \"result\" key from the dictionary returned by the yaml\nstep.</p>\n\n<p>from curses import wrapper</p>\n\n<h1 id=\"validators\">Validators</h1>\n\n<p>Validators are used to validate argument values. They are implemented as a\n<code>cli_wrapper.util.callable_chain.CallableChain</code> for serialization. Callables in the chain are called with the value\nsequentially, stopping at the first callable that returns False.</p>\n\n<h2 id=\"default-validators\">Default Validators</h2>\n\n<p>The default validators are:</p>\n\n<ul>\n<li><code>is_dict</code></li>\n<li><code>is_list</code></li>\n<li><code>is_str</code></li>\n<li><code>is_str_or_list</code></li>\n<li><code>is_int</code></li>\n<li><code>is_float</code></li>\n<li><code>is_bool</code></li>\n<li><code>is_path</code> - is a <code>pathlib.Path</code></li>\n<li><code>is_alnum</code> - is alphanumeric</li>\n<li><code>is_alpha</code> - is alphabetic</li>\n<li><code>starts_alpha</code> - first digit is a letter</li>\n<li><code>startswith</code> - checks if the string starts with a given prefix</li>\n</ul>\n\n<h2 id=\"custom-validators\">Custom Validators</h2>\n\n<p>You can register your own validators in <code>cli_wrapper.validators.validators</code>:</p>\n\n<ol>\n<li>Takes at most one positional argument</li>\n<li>When configuring the validator, additional arguments can be supplied using a dictionary:</li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">wrapper</span><span class=\"o\">.</span><span class=\"n\">update_command_</span><span class=\"p\">(</span><span class=\"s2\">&quot;cmd&quot;</span><span class=\"p\">,</span> <span class=\"n\">validators</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">&quot;arg&quot;</span><span class=\"p\">:[</span><span class=\"s2\">&quot;is_str&quot;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">&quot;startswith&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s2\">&quot;prefix&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;prefix&quot;</span><span class=\"p\">}}]})</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">wrapper</span><span class=\"o\">.</span><span class=\"n\">update_command_</span><span class=\"p\">(</span><span class=\"s2\">&quot;cmd&quot;</span><span class=\"p\">,</span> <span class=\"n\">validators</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">&quot;arg&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;is_str&quot;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">&quot;startswith&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;prefix&quot;</span><span class=\"p\">}]})</span>\n</code></pre>\n</div>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">cli_wrapper</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">CLIWrapper</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">cli_wrapper.validators</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">validators</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">is_alnum_or_dash</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">isalnum</span><span class=\"p\">()</span> <span class=\"ow\">or</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;-&quot;</span> <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"n\">validators</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">&quot;is_alnum_or_dash&quot;</span><span class=\"p\">,</span> <span class=\"n\">is_alnum_or_dash</span><span class=\"p\">)</span>\n\n<span class=\"n\">kubectl</span> <span class=\"o\">=</span> <span class=\"n\">CLIWrapper</span><span class=\"p\">(</span><span class=\"s2\">&quot;kubectl&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\"># 1 refers to the first positional argument, so in `kubectl.get(&quot;pods&quot;, &quot;my-pod&quot;)` it would refer to `&quot;my-pod&quot;`</span>\n<span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">update_command_</span><span class=\"p\">(</span><span class=\"s2\">&quot;get&quot;</span><span class=\"p\">,</span> <span class=\"n\">validators</span><span class=\"o\">=</span><span class=\"p\">{</span>\n <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">&quot;is_str&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;is_alnum_or_dash&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;starts_alpha&quot;</span><span class=\"p\">],</span>\n<span class=\"p\">})</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">&quot;pods&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;my-pod&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">threw</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">&quot;pods&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;level-9000-pod!!&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n    <span class=\"n\">threw</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">threw</span>\n</code></pre>\n</div>\n\n<h1 id=\"parsers\">Parsers</h1>\n\n<p>Parsers provide a mechanism to convert the output of a CLI tool into a usable structure. They make use of\n<code>cli_wrapper.util.callable_chain.CallableChain</code> to be serializable-ish.</p>\n\n<h2 id=\"default-parsers\">Default Parsers</h2>\n\n<ol>\n<li><code>json</code>: uses <code>json.loads</code> to parse stdout</li>\n<li><code>extract</code>: extracts data from the raw output, using the args as a list of nested keys.</li>\n<li><code>yaml</code>: if <code>ruamel.yaml</code> is installed, uses <code>YAML().load_all</code> to read stdout. If <code>load_all</code> only returns one\ndocument, it returns that document. Otherwise, it returns a list of documents. <code>pyyaml</code> is also supported.</li>\n<li><code>dotted_dict</code>: if <code>dotted_dict</code> is installed, converts an input dict or list to a <code>PreserveKeysDottedDict</code> or \na list of them. This lets you refer to most dictionary keys as <code>a.b.c</code> instead of <code>a[\"b\"][\"c\"]</code>.</li>\n</ol>\n\n<p>These can be combined in a list in the <code>parse</code> argument to <code>cli_wrapper.cli_wrapper.CLIWrapper.update_command_</code>,\nallowing the result of the call to be immediately usable.</p>\n\n<p>You can also register your own parsers in <code>cli_wrapper.parsers.parsers</code>, which is a \n<code>cli_wrapper.util.callable_registry.CallableRegistry</code>.</p>\n\n<h2 id=\"examples-2\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">cli_wrapper</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">CLIWrapper</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">skip_lists</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">):</span> \n    <span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;kind&quot;</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;List&quot;</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;items&quot;</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n<span class=\"n\">kubectl</span> <span class=\"o\">=</span> <span class=\"n\">CLIWrapper</span><span class=\"p\">(</span><span class=\"s2\">&quot;kubectl&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\"># you can use the parser directly, but you won&#39;t be able to serialize the</span>\n<span class=\"c1\"># wrapper to json</span>\n<span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">update_command_</span><span class=\"p\">(</span>\n   <span class=\"s2\">&quot;get&quot;</span><span class=\"p\">,</span>\n   <span class=\"n\">parse</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;json&quot;</span><span class=\"p\">,</span> <span class=\"n\">skip_lists</span><span class=\"p\">,</span> <span class=\"s2\">&quot;dotted_dict&quot;</span><span class=\"p\">],</span>\n   <span class=\"n\">default_flags</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;--output&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;json&quot;</span><span class=\"p\">]</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">&quot;pods&quot;</span><span class=\"p\">,</span> <span class=\"n\">namespace</span><span class=\"o\">=</span><span class=\"s2\">&quot;kube-system&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">)</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">&quot;pods&quot;</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">namespace</span><span class=\"o\">=</span><span class=\"s2\">&quot;kube-system&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">name</span>\n</code></pre>\n</div>\n\n<h1 id=\"transformers\">Transformers</h1>\n\n<p>Argument transformers receive an argument (either a numbered positional argument or a string keywork argument/flag) and\na value. They return a tuple of argument and value that replace the original.</p>\n\n<p>The main transformer used by cli-wrapper is <code>cli_wrapper.transformers.snake2kebab</code>, which converts a <code>an_argument_like_this</code> to\n<code>an-argument-like-this</code> and returns the value unchanged. This is the default transformer for all keyword arguments.</p>\n\n<p>Transformers are added to a callable registry, so they can be refernced as a string after they're registered.\nTransformers are not currently chained.</p>\n\n<h2 id=\"other-possibilities-for-transformers\">Other possibilities for transformers</h2>\n\n<h3 id=\"1-write-dictionaries-to-files-and-return-a-flag-referencing-a-file\">1. Write dictionaries to files and return a flag referencing a file</h3>\n\n<p>Consider a command like <code>kubectl create</code>: the primary argument is a filename or list of files. Say you have your \nmanifest to create as a dictionary:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathlib</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">ruamel.yaml</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">YAML</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">cli_wrapper</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">transformers</span><span class=\"p\">,</span> <span class=\"n\">CLIWrapper</span>\n\n<span class=\"n\">manifest_count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">base_filename</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;my_manifest&quot;</span>\n<span class=\"n\">base_dir</span> <span class=\"o\">=</span> <span class=\"n\">Path</span><span class=\"p\">()</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">YAML</span><span class=\"p\">()</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">write_manifest</span><span class=\"p\">(</span><span class=\"n\">manifest</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]):</span>\n    <span class=\"k\">global</span> <span class=\"n\">manifest_count</span>\n    <span class=\"n\">manifest_count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"n\">base_dir</span> <span class=\"o\">/</span> <span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">base_filename</span><span class=\"si\">}</span><span class=\"s2\">_</span><span class=\"si\">{</span><span class=\"n\">manifest_count</span><span class=\"si\">}</span><span class=\"s2\">.yaml&quot;</span>\n    <span class=\"k\">with</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s2\">&quot;w&quot;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">manifest</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">):</span>\n            <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">dump_all</span><span class=\"p\">(</span><span class=\"n\">manifest</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">manifest</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">as_posix</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">manifest_transformer</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">writer</span><span class=\"o\">=</span><span class=\"n\">write_manifest</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s2\">&quot;filename&quot;</span><span class=\"p\">,</span> <span class=\"n\">writer</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n<span class=\"n\">transformers</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">&quot;manifest&quot;</span><span class=\"p\">,</span> <span class=\"n\">manifest_transformer</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># If you had different writer functions (e.g., different base name), you could register those as partials:</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">functools</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">partial</span>\n<span class=\"n\">transformers</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">&quot;other_manifest&quot;</span><span class=\"p\">,</span> <span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">manifest_transformer</span><span class=\"p\">,</span> <span class=\"n\">writer</span><span class=\"o\">=</span><span class=\"n\">my_other_writer</span><span class=\"p\">))</span>\n\n<span class=\"n\">kubectl</span> <span class=\"o\">=</span> <span class=\"n\">CLIWrapper</span><span class=\"p\">(</span><span class=\"s1\">&#39;kubectl&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">update_command_</span><span class=\"p\">(</span><span class=\"s2\">&quot;create&quot;</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">&quot;data&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s2\">&quot;transformer&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;manifest&quot;</span><span class=\"p\">}})</span>\n\n<span class=\"c1\"># will write the manifest to &quot;my_manifest_1.yaml&quot; and execute `kubectl create -f my_manifest_1.yaml`</span>\n<span class=\"n\">kubectl</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">my_kubernetes_manifest</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h2 id=\"possible-future-changes\">Possible future changes</h2>\n\n<ul>\n<li>it might make sense to make transformers a <a href=\"callable_serialization.md#callablechain\"><code>CallableChain</code></a> similar to parser so a sequence of things can be done on an arg</li>\n<li>it might also make sense to support transformers that break individual args into multiple args with separate values</li>\n</ul>\n"}, {"fullname": "cli_wrapper.cli_wrapper", "modulename": "cli_wrapper.cli_wrapper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.cli_wrapper.Argument", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument", "kind": "class", "doc": "<p>Argument represents a command line argument to be passed to the cli_wrapper</p>\n"}, {"fullname": "cli_wrapper.cli_wrapper.Argument.__init__", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument.__init__", "kind": "function", "doc": "<p>Method generated by attrs for class Argument.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">literal_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">validator</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">transformer</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;snake2kebab&#39;</span></span>)</span>"}, {"fullname": "cli_wrapper.cli_wrapper.Argument.from_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument.from_dict", "kind": "function", "doc": "<p>Create an Argument from a dictionary</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arg_dict</strong>:  the dictionary to be converted</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Argument object</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">arg_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Argument.to_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument.to_dict", "kind": "function", "doc": "<p>Convert the Argument to a dictionary</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the dictionary representation of the Argument</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Argument.is_valid", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument.is_valid", "kind": "function", "doc": "<p>Validate the value of the argument</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong>:  the value to be validated</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>True if valid, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Argument.transform", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Argument.transform", "kind": "function", "doc": "<p>Transform the name and value of the argument</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong>:  the name of the argument</li>\n<li><strong>value</strong>:  the value to be transformed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the transformed value</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Command", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command", "kind": "class", "doc": "<p>Command represents a command to be run with the cli_wrapper</p>\n"}, {"fullname": "cli_wrapper.cli_wrapper.Command.__init__", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command.__init__", "kind": "function", "doc": "<p>Method generated by attrs for class Command.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cli_command</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">default_flags</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"n\">NOTHING</span>,</span><span class=\"param\">\t<span class=\"n\">parse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">default_transformer</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;snake2kebab&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">short_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">long_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;--&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">arg_separator</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;=&#39;</span></span>)</span>"}, {"fullname": "cli_wrapper.cli_wrapper.Command.from_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command.from_dict", "kind": "function", "doc": "<p>Create a Command from a dictionary</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>command_dict</strong>:  the dictionary to be converted</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Command object</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">command_dict</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Command.to_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command.to_dict", "kind": "function", "doc": "<p>Convert the Command to a dictionary.\nExcludes prefixes/separators, because they are set in the CLIWrapper</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the dictionary representation of the Command</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Command.validate_args", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command.validate_args", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.Command.build_args", "modulename": "cli_wrapper.cli_wrapper", "qualname": "Command.build_args", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.CLIWrapper", "modulename": "cli_wrapper.cli_wrapper", "qualname": "CLIWrapper", "kind": "class", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  The path to the CLI tool. This will be passed to subprocess directly, and does not require a full path\nunless the tool is not in the system path.</li>\n<li><strong>env</strong>:  A dict of environment variables to be set in the subprocess environment, in addition to and overriding\nthose in os.environ.</li>\n<li><strong>trusting</strong>:  If True, the wrapper will accept any command and pass them to the cli with default configuration.\nOtherwise, it will only allow commands that have been defined with <code>update_command_</code></li>\n<li><strong>raise_exc</strong>:  If True, the wrapper will raise an exception if a command returns a non-zero exit code.</li>\n<li><strong>async_</strong>:  If true, the wrapper will return coroutines that must be awaited.</li>\n<li><strong>default_transformer</strong>:  The transformer configuration to apply to all arguments. The default of snake2kebab will\nconvert pythonic_snake_case_kwargs to kebab-case-arguments</li>\n<li><strong>short_prefix</strong>:  The string prefix for single-letter arguments</li>\n<li><strong>long_prefix</strong>:  The string prefix for arguments longer than 1 letter</li>\n<li><strong>arg_separator</strong>:  The character that separates argument values from names. Defaults to '=', so\nwrapper.command(arg=value) would become \"wrapper command --arg=value\"</li>\n</ul>\n"}, {"fullname": "cli_wrapper.cli_wrapper.CLIWrapper.__init__", "modulename": "cli_wrapper.cli_wrapper", "qualname": "CLIWrapper.__init__", "kind": "function", "doc": "<p>Method generated by attrs for class CLIWrapper.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">env</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">commands</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">cli_wrapper</span><span class=\"o\">.</span><span class=\"n\">cli_wrapper</span><span class=\"o\">.</span><span class=\"n\">Command</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">trusting</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">raise_exc</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">async_</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">default_transformer</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;snake2kebab&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">short_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">long_prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;--&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">arg_separator</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;=&#39;</span></span>)</span>"}, {"fullname": "cli_wrapper.cli_wrapper.CLIWrapper.update_command_", "modulename": "cli_wrapper.cli_wrapper", "qualname": "CLIWrapper.update_command_", "kind": "function", "doc": "<p>update the command to be run with the cli_wrapper</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>command</strong>:  the command name for the wrapper</li>\n<li><strong>cli_command</strong>:  the command to be run, if different from the command name</li>\n<li><strong>args</strong>:  the arguments passed to the command</li>\n<li><strong>default_flags</strong>:  default flags to be used with the command</li>\n<li><strong>parse</strong>:  function to parse the output of the command</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">command</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">cli_command</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">default_flags</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">parse</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.CLIWrapper.from_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "CLIWrapper.from_dict", "kind": "function", "doc": "<p>Create a CLIWrapper from a dictionary</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>cliwrapper_dict</strong>:  the dictionary to be converted</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>CLIWrapper object</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">cliwrapper_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.cli_wrapper.CLIWrapper.to_dict", "modulename": "cli_wrapper.cli_wrapper", "qualname": "CLIWrapper.to_dict", "kind": "function", "doc": "<p>Convert the CLIWrapper to a dictionary</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a dictionary that can be used to recreate the wrapper using <code>from_dict</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.parsers", "modulename": "cli_wrapper.parsers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.parsers.extract", "modulename": "cli_wrapper.parsers", "qualname": "extract", "kind": "function", "doc": "<p>Extracts a sub-dictionary from a source dictionary based on a given path.\nTODO: this</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>src</strong>:  The source dictionary to extract from.</li>\n<li><strong>path</strong>:  A list of keys representing the path to the sub-dictionary.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The extracted sub-dictionary.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.parsers.core_parsers", "modulename": "cli_wrapper.parsers", "qualname": "core_parsers", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;extract&#x27;: &lt;function extract&gt;, &#x27;json&#x27;: &lt;function loads&gt;, &#x27;yaml&#x27;: &lt;function yaml_loads&gt;, &#x27;dotted_dict&#x27;: &lt;function dotted_dictify&gt;}"}, {"fullname": "cli_wrapper.parsers.parsers", "modulename": "cli_wrapper.parsers", "qualname": "parsers", "kind": "variable", "doc": "<p>A <code>CallableRegistry</code> of parsers. These can be chained in sequence to perform \noperations on input.</p>\n\n<p>Defaults:\ncore parsers:</p>\n\n<ul>\n<li>json - parses the input as json, returns the result</li>\n<li>extract - extracts the specified sub-dictionary from the source dictionary</li>\n<li>yaml - parses the input as yaml, returns the result (requires ruamel.yaml or pyyaml)</li>\n<li>dotted_dict - converts an input dictionary to a dotted_dict (requires dotted_dict)</li>\n</ul>\n", "default_value": "CallableRegistry(_all={&#x27;core&#x27;: {&#x27;extract&#x27;: &lt;function extract&gt;, &#x27;json&#x27;: &lt;function loads&gt;, &#x27;yaml&#x27;: &lt;function yaml_loads&gt;, &#x27;dotted_dict&#x27;: &lt;function dotted_dictify&gt;}}, callable_name=&#x27;Parser&#x27;)"}, {"fullname": "cli_wrapper.parsers.Parser", "modulename": "cli_wrapper.parsers", "qualname": "Parser", "kind": "class", "doc": "<p>@public\nParser class that allows for the chaining of multiple parsers. Callables in the configuration are run as a\npipeline, with the output of one parser being passed as input to the next.</p>\n", "bases": "cli_wrapper.util.callable_chain.CallableChain"}, {"fullname": "cli_wrapper.parsers.Parser.__init__", "modulename": "cli_wrapper.parsers", "qualname": "Parser.__init__", "kind": "function", "doc": "<p>@public</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong>:  a callable, a string, a dictionary with one key and config, or a list of the previous</li>\n<li><strong>source</strong>:  a <code>CallableRegistry</code> to get callables from</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "cli_wrapper.parsers.yaml_loads", "modulename": "cli_wrapper.parsers", "qualname": "yaml_loads", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.parsers.dotted_dictify", "modulename": "cli_wrapper.parsers", "qualname": "dotted_dictify", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.pre_packaged", "modulename": "cli_wrapper.pre_packaged", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.pre_packaged.get_wrapper", "modulename": "cli_wrapper.pre_packaged", "qualname": "get_wrapper", "kind": "function", "doc": "<p>Gets a wrapper defined in the beta/stable folders as json.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong>:  the name of the wrapper to retrieve</li>\n<li><strong>status</strong>:  stable/beta/None. None will search stable and beta</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>the requested wrapper</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">status</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.transformers", "modulename": "cli_wrapper.transformers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.transformers.snake2kebab", "modulename": "cli_wrapper.transformers", "qualname": "snake2kebab", "kind": "function", "doc": "<p><code>snake.gravity = 0</code></p>\n\n<p>converts a snake_case argument to a kebab-case one</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.transformers.transformers", "modulename": "cli_wrapper.transformers", "qualname": "transformers", "kind": "variable", "doc": "<p>A callable registry of transformers.</p>\n\n<p>Defaults:\ncore group:</p>\n\n<ul>\n<li>snake2kebab</li>\n</ul>\n", "default_value": "CallableRegistry(_all={&#x27;core&#x27;: {&#x27;snake2kebab&#x27;: &lt;function snake2kebab&gt;}}, callable_name=&#x27;Callable thing&#x27;)"}, {"fullname": "cli_wrapper.util", "modulename": "cli_wrapper.util", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.util.CallableRegistry", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry", "kind": "class", "doc": "<p>Stores collections of callables. @public</p>\n\n<ul>\n<li>callables are registered by name</li>\n<li>they are retrieved by name with args and kwargs</li>\n<li>calling the callable with positional arguments will call the callable\nwith the args in the call, plus any args and kwargs passed to get()</li>\n</ul>\n"}, {"fullname": "cli_wrapper.util.CallableRegistry.__init__", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry.__init__", "kind": "function", "doc": "<p>Method generated by attrs for class CallableRegistry.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"nb\">all</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">callable_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Callable thing&#39;</span></span>)</span>"}, {"fullname": "cli_wrapper.util.CallableRegistry.callable_name", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry.callable_name", "kind": "variable", "doc": "<p>a name of the things in the registry to use in error messages</p>\n", "annotation": ": str"}, {"fullname": "cli_wrapper.util.CallableRegistry.get", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry.get", "kind": "function", "doc": "<p>Retrieves a callable function based on the specified parser name.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong>:  The name of the callable to retrieve.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The corresponding callable function.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError</strong>:  If the specified callable name is not found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">kwargs</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.util.CallableRegistry.register", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry.register", "kind": "function", "doc": "<p>Registers a new callable function with the specified name.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong>:  The name to associate with the callable.</li>\n<li><strong>callable_</strong>:  The callable function to register.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">callable_</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">callable</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">group</span><span class=\"o\">=</span><span class=\"s1\">&#39;core&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.util.CallableRegistry.register_group", "modulename": "cli_wrapper.util", "qualname": "CallableRegistry.register_group", "kind": "function", "doc": "<p>Registers a new callable group with the specified name.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong>:  The name to associate with the callable group.</li>\n<li><strong>callables</strong>:  A dictionary of callables to register in the group.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">callables</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.util.CallableChain", "modulename": "cli_wrapper.util", "qualname": "CallableChain", "kind": "class", "doc": "<p>A callable object representing a collection of callables.</p>\n", "bases": "abc.ABC"}, {"fullname": "cli_wrapper.util.CallableChain.__init__", "modulename": "cli_wrapper.util", "qualname": "CallableChain.__init__", "kind": "function", "doc": "<p>@public</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong>:  a callable, a string, a dictionary with one key and config, or a list of the previous</li>\n<li><strong>source</strong>:  a <code>CallableRegistry</code> to get callables from</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span>, </span><span class=\"param\"><span class=\"n\">source</span></span>)</span>"}, {"fullname": "cli_wrapper.util.CallableChain.chain", "modulename": "cli_wrapper.util", "qualname": "CallableChain.chain", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[callable]"}, {"fullname": "cli_wrapper.util.CallableChain.config", "modulename": "cli_wrapper.util", "qualname": "CallableChain.config", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "cli_wrapper.util.CallableChain.to_dict", "modulename": "cli_wrapper.util", "qualname": "CallableChain.to_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "cli_wrapper.validators", "modulename": "cli_wrapper.validators", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.validators.core_validators", "modulename": "cli_wrapper.validators", "qualname": "core_validators", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;is_dict&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_list&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_str&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_str_or_list&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_int&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_bool&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_float&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_alnum&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_alpha&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_digit&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_path&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;starts_alpha&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;startswith&#x27;: &lt;function &lt;lambda&gt;&gt;}"}, {"fullname": "cli_wrapper.validators.validators", "modulename": "cli_wrapper.validators", "qualname": "validators", "kind": "variable", "doc": "<p></p>\n", "default_value": "CallableRegistry(_all={&#x27;core&#x27;: {&#x27;is_dict&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_list&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_str&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_str_or_list&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_int&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_bool&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_float&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_alnum&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_alpha&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_digit&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;is_path&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;starts_alpha&#x27;: &lt;function &lt;lambda&gt;&gt;, &#x27;startswith&#x27;: &lt;function &lt;lambda&gt;&gt;}}, callable_name=&#x27;Validator&#x27;)"}, {"fullname": "cli_wrapper.validators.Validator", "modulename": "cli_wrapper.validators", "qualname": "Validator", "kind": "class", "doc": "<p>@public</p>\n\n<p>A class that provides a validation mechanism for input data.\nIt uses a list of validators to check if the input data is valid.\nThey are executed in sequence until one fails.</p>\n", "bases": "cli_wrapper.util.callable_chain.CallableChain"}, {"fullname": "cli_wrapper.validators.Validator.__init__", "modulename": "cli_wrapper.validators", "qualname": "Validator.__init__", "kind": "function", "doc": "<p>@public</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>config</strong>:  a callable, a string, a dictionary with one key and config, or a list of the previous</li>\n<li><strong>source</strong>:  a <code>CallableRegistry</code> to get callables from</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">config</span></span>)</span>"}, {"fullname": "cli_wrapper.validators.Validator.config", "modulename": "cli_wrapper.validators", "qualname": "Validator.config", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "cli_wrapper.validators.Validator.to_dict", "modulename": "cli_wrapper.validators", "qualname": "Validator.to_dict", "kind": "function", "doc": "<p>Converts the validator configuration to a dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();